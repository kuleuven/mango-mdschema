"""Helper functions for the mango_mdschema package."""

from datetime import datetime, date, time
import re
from collections.abc import MutableMapping
import warnings
from irods.meta import iRODSMeta


def flatten(value, key=None, delim="."):
    """Walk nested dicts and lists and yield flattened key and value pairs.

    This function is used to flatten a nested dictionaries and embedded lists.
    The yielded values are tuples (key, value). The key is the flattened key and the
    value is the value corresponding to the flattened key.

    Flattened keys are generated by concatenating the keys of the nested
    dictionaries with the delimiter. For example, the key 'a.b.c' corresponds
    to the value of the key 'c' in the dictionary 'b', which is the value of
    the key 'a' in the root dictionary. The key 'a[0].b' corresponds to the value
    of the key 'b' in the first element of the list 'a'. The key 'a[0].b.c' corresponds
    to the value of the key 'c' in the dictionary 'b', which is the first element of
    the list 'a'.

    If a different format is required, the flatten function can be used in combination
    with the `map()` function. For example, to generate AVUs based on the flattened
    key/value pairs, the following code can be used:

        ```
        avus = list(map(flattened_to_mango_avu, flatten(data)))
        ```

    Args:
        value (any): metadata to flatten.
        key (str, optional): Flattened key of the current value. Defaults to None.
        delim (str, optional): Delimiter to use to flatten keys. Defaults to '.'.
    Returns:
        generator: Generator of tuples (key, value).
    """
    if isinstance(value, MutableMapping):
        for subkey, item in value.items():
            yield from flatten(item, f"{key}{delim}{subkey}" if key else subkey, delim)
    elif isinstance(value, list):
        for i, item in enumerate(value):
            yield from flatten(item, f"{key}[{i}]", delim)
    elif value is not None:
        yield (key, value)


def unflatten(items, delim="."):
    """Unflatten a list of (key, value) tuples into a nested dictionary.

    Caveats:
    - If a key is a number or a string containing only digits, it is considered as a list index.
    - Keys may not contain the delimiter.

    Args:
        items (list): List of tuples (key, value) with flattened keys.
        delim (str, optional): Delimiter used in the flattened keys. Defaults to '.'.

    Returns:
        dict: Nested dictionary.
    """

    def insert(root, parts, value):  # pylint: disable=too-many-branches
        # handle leaf values
        if len(parts) == 1:
            # handle list indices
            if parts[0].isdigit() and isinstance(root, list):
                index = int(parts[0])
                if index >= len(root):
                    root.extend([None] * (index - len(root) + 1))
                root[index] = value

            # handle multiple values for the same key, this can happen when
            # the list indices of a simple repeatable field or select field
            # were not added to the flattened keys.
            elif parts[0] in root:
                if isinstance(root[parts[0]], list):
                    root[parts[0]].append(value)
                else:  # convert to list
                    root[parts[0]] = [root[parts[0]], value]

            # handle simple values
            else:
                root[parts[0]] = value
            return

        # handle dicts and lists
        part = int(parts[0]) if parts[0].isdigit() else parts[0]
        if len(parts) > 1 and parts[1].isdigit():  # check if next part is a digit
            # handle lists
            if part not in root:
                root[part] = []
            if isinstance(root[part], list):
                index = int(parts[1])
                if index >= len(root[part]):
                    root[part].extend([{}] * (index - len(root[part]) + 1))
                if len(parts) > 2:  # check if there are more parts
                    insert(root[part][index], parts[2:], value)
                else:
                    insert(root[part], parts[1:], value)
        else:
            if part not in root:
                root[part] = {}
            insert(root[part], parts[1:], value)

    root = {}
    # sort items by key to ensure that parents are created before children
    # and order of items in lists is preserved.
    for key, value in sorted(
        items,
        key=lambda x: [
            int(i) if i.isdigit() else i
            for i in re.split(f"{re.escape(delim)}|\\[|\\]", x[0])
        ],
    ):
        parts = re.split(f"{re.escape(delim)}|\\[|\\]", key)
        parts = [part for part in parts if part]  # remove empty strings from parts
        insert(root, parts, value)
    return root


def flattened_to_mango_avu(flattened: tuple, prefix: str = None) -> iRODSMeta:
    """ "Convert a normalized flattened key/value pair yielded by the `flatten`
    generator to a iRODSMeta object with name, value and units accoording to
    the ManGO metadata specification.

    A datetime, date or time object is converted to an ISO 8601 string and
    a boolean is converted to a string 'true' or 'false'.

    This function is the default converter used by the `Schema` class.

    Args:
        flattened (tuple): Tuple (key, value) with flattened key.
        prefix (str, optional): Prefix to add to the AVU name. Defaults to None.
    Returns:
        iRODSMeta: the iRODS AVU object with mapt name, value and units.
    """
    key, value = flattened
    if isinstance(value, (datetime, date, time)):
        value = value.isoformat()
    elif isinstance(value, bool):
        value = str(value).lower()
    elif isinstance(value, (int, float)):
        value = str(value)
    # The flattened key is a string with the format 'a[0].b.c[1].e' and
    # this is converted to a triple (name, value, units) with the format
    # ('a.b.c.d.e', value, '1.0.2').
    parts = re.split(r"\.", key)
    indices = []
    if len(parts) > 1:
        for part in parts:
            match = re.search(r"\[(\d+)\]", part)
            index = int(match.group(1)) + 1 if match else 0
            indices.append(str(index))
        # Remove any index from the last part. Simple fields should not have
        # have an index in the units string, also not if they are repeatable.
        indices.pop()
        # Change all 0 indices to 1, in the current implementation of the
        # ManGO metadata specification, non-repeatable composite fields also
        # need to have index 1 in the units string.
        indices = ["1" if i == "0" else i for i in indices]
    name = re.sub(r"\[\d+\]", "", key)  # remove list indices from the normalized key
    units = ".".join(indices).rstrip(".0")  # remove trailing zero indices
    return iRODSMeta(
        name=f"{prefix}.{name}" if prefix else name,
        value=value,
        units=units if units != "" else None,
    )


def flattened_from_mango_avu(avu: iRODSMeta, prefix=None):
    """Convert an iRODSmeta object to a tuple of flattened key/value pairs
    that can be used as input to the `unflatten` function to create a
    nested metadata dictionary from the AVUs based on the ManGO metadata
    specification.

    This function is the default converter used by the `Schema` class.

    Args:
      avu (iRODSMeta): iRODSMeta object.
      prefix (str, optional): Prefix to remove from the AVU name. Defaults to None.
    """
    name = avu.name.replace(f"{prefix}.", "", 1) if prefix else avu.name

    # Split the units string into a list of indices
    if avu.units:
        indices = avu.units.split(".")
        indices = [int(i) - 1 for i in indices]  # subtract 1 to get zero-based indices

        # Split the name into parts
        name_parts = name.split(".")

        # Combine the name parts and indices
        name = ".".join(
            f"{part}[{index}]" if index >= 0 else part
            for part, index in zip(
                name_parts, indices + [-1] * (len(name_parts) - len(indices))
            )
        )

    # Return the tuple of flattened key and value
    return (name, avu.value)


def check_metadata(
    schema,
    metadata: dict,
    verbose: bool = False,  # pylint: disable=unused-argument
    index: str = None,  # pylint: disable=unused-argument
) -> list:
    """Check that the metadata for a schema or composite field is valid and generate the AVUs.

    Deprecated, use the `Schema.to_avus()` or `Schema.validate()` method instead.

    Args:
        schema (schema.Schema | fields.CompositeField): A schema or composite field.
        metadata (dict): Dictionary with metadata to apply.
        verbose (bool, optional): Obsolete. Set logging level to INFO instead.
        index (str, optional): Obsolete. Index is automatically generated by the schema.

    Raises:
        KeyError: When a required field is missing and there is no default.

    Returns:
        list of iRODSMeta: Processed AVUs.
    """
    warnings.warn(
        "This method is deprecated, use Schema.to_avus() or Schema.validate() instead.",
        DeprecationWarning,
    )

    # make sure that the required fields are present
    missing_required = [
        schema.fields[field_name].avu_name
        for field_name, default in schema.required_fields.items()
        if field_name not in metadata.keys() and default is None
    ]
    # raise error if any required field is not present and there is no default
    if len(missing_required) > 0:
        raise KeyError(
            (
                "The following required fields are missing and there is no default: "
                f"{', '.join(missing_required)}."
            )
        )
    return schema.to_avus(metadata)


def bold(string: str) -> str:
    """Return the string in bold. Useful for printing."""
    return f"\033[1m{string}\033[0m"


def is_number(value: str) -> bool:
    """Check if a string is a number (float or int)."""
    try:
        float(value)
        return True
    except ValueError:
        return False
