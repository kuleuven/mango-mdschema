"""Helper functions for the mango_mdschema package."""
from datetime import datetime, date, time
import re
from collections.abc import MutableMapping
import warnings
from irods.meta import iRODSMeta


def flatten(value, key=None, delim="."):
    """Walk nested dicts and lists and yield flattened key and value pairs.

    This function is used to flatten a nested dictionaries and embedded lists.
    The yielded values are tuples (key, value). The key is the flattened key and the
    value is the value corresponding to the flattened key.

    Flattened keys are generated by concatenating the keys of the nested
    dictionaries with the delimiter. For example, the key 'a.b.c' corresponds
    to the value of the key 'c' in the dictionary 'b', which is the value of
    the key 'a' in the root dictionary. The key 'a[0].b' corresponds to the value
    of the key 'b' in the first element of the list 'a'. The key 'a[0].b.c' corresponds
    to the value of the key 'c' in the dictionary 'b', which is the first element of
    the list 'a'.

    If a different format is required, the flatten function can be used in combination
    with the `map()` function. For example, to generate AVUs based on the flattened
    key/value pairs, the following code can be used:

        ```
        avus = list(map(flattened_to_avu, flatten(data)))
        ```

    Args:
        value (any): metadata to flatten.
        key (str, optional): Flattened key of the current value. Defaults to None.
        delim (str, optional): Delimiter to use to flatten keys. Defaults to '.'.
    Returns:
        generator: Generator of tuples (key, value).
    """
    if isinstance(value, MutableMapping):
        for subkey, item in value.items():
            yield from flatten(item, f"{key}{delim}{subkey}" if key else subkey, delim)
    elif isinstance(value, list):
        for i, item in enumerate(value):
            yield from flatten(item, f"{key}[{i}]", delim)
    else:
        yield (key, value)


def unflatten(items, delim="."):
    """Unflatten a list of (key, value) tuples into a nested dictionary.

    Caveats:
    - If a key is a number or a string containing only digits, it is considered as a list index.
    - Keys may not contain the delimiter.

    Args:
        items (list): List of tuples (key, value) with flattened keys.
        delim (str, optional): Delimiter used in the flattened keys. Defaults to '.'.

    Returns:
        dict: Nested dictionary.
    """

    def insert(root, parts, value):  # pylint: disable=too-many-branches
        # handle leaf values
        if len(parts) == 1:
            # handle list indices
            if parts[0].isdigit() and isinstance(root, list):
                index = int(parts[0])
                if index >= len(root):
                    root.extend([None] * (index - len(root) + 1))
                root[index] = value

            # handle multiple values for the same key, this can happen when
            # the list indices of a simple repeatable field or select field
            # were not added to the flattened keys.
            elif parts[0] in root:
                if isinstance(root[parts[0]], list):
                    root[parts[0]].append(value)
                else:  # convert to list
                    root[parts[0]] = [root[parts[0]], value]

            # handle simple values
            else:
                root[parts[0]] = value
            return

        # handle dicts and lists
        part = int(parts[0]) if parts[0].isdigit() else parts[0]
        if len(parts) > 1 and parts[1].isdigit():  # check if next part is a digit
            # handle lists
            if part not in root:
                root[part] = []
            if isinstance(root[part], list):
                index = int(parts[1])
                if index >= len(root[part]):
                    root[part].extend([{}] * (index - len(root[part]) + 1))
                if len(parts) > 2:  # check if there are more parts
                    insert(root[part][index], parts[2:], value)
                else:
                    insert(root[part], parts[1:], value)
        else:
            if part not in root:
                root[part] = {}
            insert(root[part], parts[1:], value)

    root = {}
    # sort items by key to ensure that parents are created before children
    # and order of items in lists is preserved.
    for key, value in sorted(
        items,
        key=lambda x: [
            int(i) if i.isdigit() else i
            for i in re.split(f"{re.escape(delim)}|\\[|\\]", x[0])
        ],
    ):
        parts = re.split(f"{re.escape(delim)}|\\[|\\]", key)
        parts = [part for part in parts if part]  # remove empty strings from parts
        insert(root, parts, value)
    return root


def flattened_to_avu(flattened: tuple, prefix: str = None) -> iRODSMeta:
    """ "Convert a flattened key/value pair yielded by the `flatten`
    generator to a iRODSMeta object.

    A datetime, date or time object is converted to an ISO 8601 string and
    a boolean is converted to a string 'true' or 'false'.

    Args:
        flattened (tuple): Tuple (key, value) with flattened key.
        prefix (str, optional): Prefix to add to the AVU name. Defaults to None.
    Returns:
        dict: Dictionary with keys 'name', 'value', and 'units'.
    """
    key, value = flattened
    if isinstance(value, (datetime, date, time)):
        value = value.isoformat()
    elif isinstance(value, bool):
        value = str(value).lower()
    # The flattened key is a string with the format 'a[0].b.c[1].e' and
    # this is converted to a triple (name, value, units) with the format
    # ('a.b.c.d.e', value, '1.0.2').
    parts = re.split(r"\.", key)
    indices = []
    if len(parts) > 1:
        for part in parts:
            match = re.search(r"\[(\d+)\]", part)
            index = int(match.group(1)) + 1 if match else 0
            indices.append(str(index))
        if indices[-1] != "0":
            indices.pop()  # remove any index from the last part
    name = re.sub(r"\[\d+\]", "", key)  # remove list indices
    return iRODSMeta(
        name=f"{prefix}.{name}" if prefix else name,
        value=value,
        units=".".join(indices).rstrip(".0"),  # remove trailing zero indices
    )


def flattend_from_avu(avu: iRODSMeta, prefix=None):
    """Convert an iRODSmeta object to a tuple of flattened key/value pairs
    that can be used as input to the `unflatten` function to create a
    nested metadata dictionary

    Args:
      avu (iRODSMeta): iRODSMeta object.
      prefix (str, optional): Prefix to remove from the AVU name. Defaults to None.
    """
    name = avu.name.replace(f"{prefix}.", "", 1) if prefix else avu.name

    # Split the units string into a list of indices
    if avu.units:
        indices = avu.units.split(".")
        indices = [int(i) - 1 for i in indices]  # subtract 1 to get zero-based indices

        # Split the name into parts
        name_parts = name.split(".")

        # Combine the name parts and indices
        name = ".".join(
            f"{part}[{index}]" if index >= 0 else part
            for part, index in zip(
                name_parts, indices + [-1] * (len(name_parts) - len(indices))
            )
        )

    # Return the tuple of flattened key and value
    return (name, avu.value)


def check_metadata(
    schema,
    metadata: dict,
    verbose: bool = False,  # pylint: disable=unused-argument
    index: str = None,  # pylint: disable=unused-argument
) -> list:
    """Check that the metadata for a schema or composite field is valid and generate the AVUs.

    Deprecated, use the `Schema.to_avus()` or `Schema.validate()` method instead.

    Args:
        schema (schema.Schema | fields.CompositeField): A schema or composite field.
        metadata (dict): Dictionary with metadata to apply.
        verbose (bool, optional): Obsolete. Set logging level to INFO instead.
        index (str, optional): Obsolete. Index is automatically generated by the schema.

    Raises:
        KeyError: When a required field is missing and there is no default.

    Returns:
        list of iRODSMeta: Processed AVUs.
    """
    warnings.warn(
        "This method is deprecated, use Schema.to_avus() or Schema.validate() instead.",
        DeprecationWarning,
    )

    # make sure that the required fields are present
    missing_required = [
        schema.fields[field_name].avu_name
        for field_name, default in schema.required_fields.items()
        if field_name not in metadata.keys() and default is None
    ]
    # raise error if any required field is not present and there is no default
    if len(missing_required) > 0:
        raise KeyError(
            (
                "The following required fields are missing and there is no default: "
                f"{', '.join(missing_required)}."
            )
        )
    return schema.to_avus(metadata)


def bold(string: str) -> str:
    """Return the string in bold. Useful for printing."""
    return f"\033[1m{string}\033[0m"
